<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: vi | blog.hoatle.info]]></title>
  <link href="http://blog.hoatle.info/categories/vi/atom.xml" rel="self"/>
  <link href="http://blog.hoatle.info/"/>
  <updated>2013-12-04T22:51:07+00:00</updated>
  <id>http://blog.hoatle.info/</id>
  <author>
    <name><![CDATA[hoatle]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[September 11, 2007 - Ajax Series_Giới thiệu]]></title>
    <link href="http://blog.hoatle.info/2013/12/04/september-11-2007-ajax-series-gioi-thieu/"/>
    <updated>2013-12-04T20:19:00+00:00</updated>
    <id>http://blog.hoatle.info/2013/12/04/september-11-2007-ajax-series-gioi-thieu</id>
    <content type="html"><![CDATA[<p>Sau một thời gian ngâm cứu khá lâu (nhưng chưa kĩ lắm về Ajax, tự nhiên thấy hứng viết các entry về
chủ đề này. Tất nhiên những entry này sẽ tìm hiều Ajax từ đầu đến cuối (mình dựa vào sách để viết –
dịch). Chia sẻ cho những bạn nào không thích đọc bằng tiếng Anh. Dù sao mình vẫn thích đọc bản gốc,
các bạn nên đọc bản gốc mới thú, mới hiểu và nắm chắc vấn đề. Tuy nhiên trong quá trình dịch, chỗ
nào cần giải thích mình sẽ giải thích thêm luôn cho dễ hiểu. Cuốn “Professional Ajax” mình cho là
thâu tóm hơi bị đầy đủ các kỹ thuật Ajax. Khỏi dài dòng văn tự. Chúng ta bắt đầu nhé. Cuốn sách hơi
bị dài, khi nào rảnh rỗi có hứng mình lại viết tiếp. Các bạn có thể tìm cuốn sách này đọc, còn muốn
đọc tiếng Việt thì đọc cái này cũng hơi bị ổn. Mình viết entry này vì trên một số diễn đàn thấy
nhiều bạn thích tìm đọc tiếng Việt :> (Mỗi tội hơi lâu, đang học dịch ở trường mà &ndash;> có thời gian
ngồi type một lúc cho đỡ phí!).</p>

<!-- more -->


<p><strong>GIỚI THIỆU:</strong></p>

<p>Với những kỹ năng JavaScript nâng cao, các nhà phát triển web đã tạo ra những trải nghiệm mới cho
người duyệt web trong các ứng dụng của mình. Phá vỡ kiểu mẫu cổ điển “click-and-wait”
(“nhấn-và-đợi”) đã thống trị thế giới web ngay từ buổi sơ khai, giờ đây các nhà phát triển có thể
đem những tính năng chỉ có ở các ứng dụng desktop vào trang web bằng cách sử dụng kỹ thuật Ajax.</p>

<p>Ajax là một thuật ngữ chỉ việc sử dụng các yêu cầu HTTP bất đồng bộ (asynchoronous HTTP requests)
được khởi tạo bằng JavaScript để lấy được dữ liệu từ server mà không cần tải lại trang web. Các yêu
cầu này có thể được tạo ra và thực thi bằng rất nhiều cách và sử dụng rất nhiều định dạng truyền tải
dữ liệu khác nhau để truyền tới trình duyệt cho JavaScript xử lý. Việc kết hợp lấy dữ liệu từ xa và
tương tác với DOM (Document Object Model &ndash; mô hình đối tượng tài liệu) đã tạo ra một thế hệ các ứng
dụng web mới dường như không còn tuân theo các quy tắc truyền thống về những gì có thể diễn ra trên
web. Các công ty lớn như Google, Yahoo! và Microsoft… đã tạo ra và chia sẻ nhiều nguồn tài nguyên
đặc biệt hướng tới mục tiêu tạo các ứng dụng web chạy và trông giống như các ứng dụng trên desktop.</p>

<p>Các entry về Ajax này sẽ nói đến các khía cạnh của Ajax, bao gồm các cách khác nhau bạn có thể khởi
tạo các yêu cầu HTTP tới server “behind the scene” và các định dạng dữ liệu khác nhau để truyền cho
nhau giữa trình duyệt và server. Bạn sẽ học được các kỹ thuật và kiểu mẫu Ajax khác nhau để thực thi
giao tiếp client-server trên website hay các ứng dụng web của bạn. (máy khách: gửi yêu cầu tới máy
chủ – máy chủ: đáp lại yêu cầu của máy khách. Thực ra máy chủ phải gọi là máy phục vụ mới đúng –
nhưng mà toàn gọi là máy chủ thì cứ gọi vậy đi, đỡ gây nhầm lẫn; còn máy khách thì nên gọi là máy
người dùng thì dễ hiểu hơn :)</p>

<p><strong>AI NÊN ĐỌC CÁC ENTRY NÀY?</strong></p>

<p>Các entry này dành cho tất các các bạn quan tâm tới kỹ thuật này, các bạn phát triển các ứng dụng
web, các bạn có trình độ JavaScript trung cấp muốn hiểu nhiều hơn về ngôn ngữ này, nâng cao lên
trình độ pro :D. Àh, những bạn nào quen với các công nghệ: XML, XSLT, PHP, C#, HTML, CSS, các dịch
vụ web thì đừng bỏ qua các entry này nhé. Thật ra bạn chỉ cần biết HTML, CSS, JavaScript là có thể
sử dụng đến các kỹ thuật Ajax rồi.</p>

<p><strong>CÁC VẤN ĐỀ ĐƯỢC ĐỀ CẬP ĐẾN?</strong></p>

<p>Tất nhiên không gì khác ngoài việc giới thiệu, hướng dẫn các kỹ thuật, kiểu mẫu và các trường hợp
sử dụng Ajax.</p>

<p>Series entry này bắt đầu đi tìm hiểu nguồn gốc Ajax, sự phát triển của web, và các công nghệ mới
trực tiếp dẫn tới sự phát triển của các kỹ thuật Ajax. Chúng ta sẽ bàn chi tiết hơn về các frame,
JavaScript, cookies, XML, và XMLhttp liên quan như thế nào tới Ajax.</p>

<p>Sau phần giới thiệu này, chúng ta sẽ nói đến các kỹ thuật Ajax cụ thể. Các yêu cầu “behind the
scene” được tạo ra bằng cách sử dụng các frame ẩn (hidden), các iframe động (dynamic) (chú ý frame
và iframe sẽ được nói chi tiết sau); các cách sử dụng này sẽ được so sánh và đối chiếu, giải thích
khi nào thì nên sử dụng cách nào hơn cách nào. Để bàn luận kỹ và rõ ràng hơn, chúng ta sẽ xem xét
các yêu cầu HTTP (requests) và đáp trả HTTP (responses) được diễn ra như thế nào.</p>

<p>Một khi bạn đã có kiến thức cơ bản về các loại yêu cầu khác nhau, chúng ta sẽ đi sâu khám phá các
ví dụ khi nào và bằng cách nào sử dụng Ajax trong website và ứng dụng web. Các thuận lợi cũng như
bất lợi khi sử dụng các kiểu định dạng truyền dữ liệu khác nhau như: text thường (không theo định
dạng nào), HTML, XML, và JSON. Sau đó là bàn đến các dịch vụ web và làm sao sử dụng chúng để thể
hiện được các kỹ thuật Ajax.</p>

<p>Phần cuối cùng (chả biết có làm đến đây không nữa) sẽ hướng dẫn bạn làm một ứng dụng web Ajax đầy
đủ, hoàn thiện: AjaxMail sẽ kết hợp các kỹ thuật đã nói ở trên lại với nhau. Mình cũng sẽ giới thiệu
một số thư việc Ajax được thiết kế để việc giao tiếp Ajax dễ dàng hơn.</p>

<p><strong>CÁCH PHÂN CHIA AJAX SERIES?</strong></p>

<p>Để tiện việc theo dõi, series này sẽ được chia thành 10 phần. Mỗi phần sẽ được chia nhỏ tiếp theo
lượng từ mà phân bố. Các phần theo thứ tự sẽ là:</p>

<ul>
<li><p>Phần 1: “Ajax là gì? ” – giải thích nguồn gốc Ajax và các công nghệ liên quan. Mô tả quá trình
phát triển của Ajax khi web phát triển, và ai (nếu có) có quyền sở hữu thuật ngữ và các kỹ thuật này.</p></li>
<li><p>Phần 2: “Ajax cơ bản” – giới thiệu các cách khác nhau để thực hiện giao tiếp Ajax, bao gồm kỹ
thuật frame ẩn, inframe động và XMLHttp. Các thuận lợi cũng như bất lợi đối với mỗi cách tiếp cận,
và các hướng dẫn khi nào thì kỹ thuật nào được sử dụng.</p></li>
<li><p>Phần 3: “Các kiểu mẫu Ajax” – tập trung vào các kiểu mẫu sử dụng Ajax. Có rất nhiều cách kết hợp
Ajax vào website và các ứng dụng web. Tất cả sẽ được tổ thức thành kiểu mẫu thiết kế thuận tiện
để kết hợp sử dụng Ajax thực tế.</p></li>
<li><p>Phần 4: “XML, XPath, và XSLT” – giới thiệu XML, XPath, và XSLT là các công nghệ bổ sung Ajax. Tập
trung vào cách sử dụng XML – định dạng truyền dữ liệu và XPath, XSLT để truy xuất và hiển thị thông
tin.</p></li>
<li><p>Phần 5: “Syndication với RSS/ ATom”. – sử dụng Ajax với các định dạng tập hợp dữ liệu RSS và ATom
để tạo ra tập hợp tin tức trên nền web.</p></li>
<li><p>Phần 6: “Các dịch vụ web” – Đem các dịch vụ web vào bức tranh Ajax. Các ví dụ giải thích cách gọi
các dịch vụ web từ máy khách (máy người dùng) cũng như làm sao tạo các proxy bên server để làm
việc với các hạn chế truy cập dưới chính sách bảo mật của trình duyệt.</p></li>
<li><p>Phần 7: “JSON” &ndash; Giới thiệu JSON (JavaScript Object Notation – Chú giải đối tượng JavaScript).
Nghe dịch như vậy cũng hơi khó hiểu, đây là cách biểu diễn đối tượng JavaScript theo cách khác
ngắn gọn hơn, dễ dàng sử dụng hơn. JSON có thể được sử dụng để thay thế cho các giao tiếp Ajax.
Chúng ta cũng bàn đến những thuân lợi cũng như bất lợi khi sử dụng XML và text thông thường.</p></li>
<li><p>Phần 8: “Website Widgets” – Tập hợp các kỹ thuật từ các phần trước tập trung tạo ra các Ajax
Widget có thể chèn vào website của bạn.</p></li>
<li><p>Phần 9: “AjaxMail” – Hướng dẫn bạn hoàn thành một ứng dụng web – AjaxMail. Đúng như tên gọi của
nó, đây là một hệ thống email trên nền Ajax. Tất nhiên ứng dụng này sử dụng rất nhiều kỹ thuật
Ajax khác nhau được nói đến ở các phần trước. Đến phần này chắc là mình cũng có thể làm xong một
cái ứng dụng dễ hiểu hơn, khi đó có thể mình thay bằng ứng dụng mình viết (dự định thôi!)</p></li>
<li><p>Phần 10: “Ajax Frameworks” – Nói đến 3 Ajax Framework: JPSPAN cho PHP, DWR cho Java và JSP,
Ajax.NET cho .NET framework.</p></li>
</ul>


<h2>Bình luận</h2>

<ul>
<li>vannessar (2007-9-11 11:38:00):</li>
</ul>


<p><em>Nói đến các framework cho ajax thì trên kia mới chỉ là FW cho phía server thôi :D Những framework
cho phía client hỗ trợ lập trình JS cũng rất quan trọng và đem lại những cảm giác khác biệt rõ rệt
nhất cho người sử dụng :D Đó là EXT, ầu yé, và nhiều nữa, YUI, mootools, prototype &hellip;</em></p>

<p><em>Aniwei, cuốn này có vẻ rất hay :D Nhất là việc dành nguyên 1 chương cho JSON :D</em></p>

<ul>
<li>hoatle (2007-9-11 11:49:00):</li>
</ul>


<p><em>Ừh, Những FW cho client rất quan trọng vì ứng dụng web là hướng tới người dùng cơ mà :D. Đọc xong
mấy chương đầu thấy thích là viết entry ngay, các kỹ thuật trong sách nêu ra cũng hay, dễ hiểu.
Càng về sau mới khó :&lt;</em></p>

<ul>
<li>vannessar (2007-9-11 11:49:00):</li>
</ul>


<p><em>tiếp tục dịch đi ^ ^ hay tôi cả ông dịch xen ké chương cho nhanh \:D/</em></p>

<ul>
<li>hoatle (2007-9-11 11:53:00):</li>
</ul>


<p><em>uh, vậy ông dịch chương chẵn, tôi chương lẻ nhé. Dịch vậy cho nhanh, có gì hỏi nhau cũng dễ.</em></p>

<ul>
<li>vannessar (2007-9-12 12:09:00):</li>
</ul>


<p><em>vấn đề là chương ông đã dịch mới chỉ là introduction. Giờ tôi sẽ dịch chương 1:&lsquo;What is ajax?&rsquo;,
dành cho ông chương kĩ thuật cơ bản để nghiên cứu nhá :D</em></p>

<ul>
<li>hoatle (2007-9-12 12:37:00):</li>
</ul>


<p><em>Okie, thế cũng được.</em></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Thêm đối số vào message bundle trong OpenSocial]]></title>
    <link href="http://blog.hoatle.info/2010/01/16/them-doi-so-vao-message-bundle-trong-opensocial/"/>
    <updated>2010-01-16T21:18:00+00:00</updated>
    <id>http://blog.hoatle.info/2010/01/16/them-doi-so-vao-message-bundle-trong-opensocial</id>
    <content type="html"><![CDATA[<h2>Bài toán</h2>

<ul>
<li>Khi làm việc với message bundle trong OpenSocial để dùng nhiều ngôn ngữ trong ứng dụng tùy thuộc
vào ngôn ngữ người dùng
(<a href="http://wiki.opensocial.org/index.php?title=Localizing_OpenSocial_applications">localization</a>) đôi
khi bạn cần phải thêm đối số động vào chuỗi hiển thị.</li>
</ul>


<p>Ví dụ có chuỗi chào như này: Hello {user} trong đó user sẽ được thay bằng username tương ứng của
người dùng. Nhưng với OpenSocial api hiện tại thì không làm thế nào để thêm đối số vào được mà chỉ
có thể lấy được message tương ứng theo key cung cấp.</p>

<ul>
<li>Do vậy đây là cách làm của tớ: viết một thêm 1 class <code>eXo.social.Locale.getMsg(key)</code> và class này
cung cấp api cũng tương tự như với class <code>Prefs</code> để lấy <code>lang</code>, <code>country</code>, <code>msg</code> (class <code>Prefs</code> còn
cung cấp nhiều api khác nữa): prefs.getMsg(key). Class <code>eXo.social.Locale</code> cung cấp thêm phương thức
<code>eXo.social.Locale.getMsg(key, [val1, val2,...]);</code> để thêm đối số vào &ldquo;message bundle&rdquo;.</li>
</ul>


<!-- more -->


<h2>Giải pháp</h2>

<ul>
<li>Viết class <code>eXo.social.Locale</code>:</li>
</ul>


<p>```javascript
/<em>*
 * Locale.js
 * Utility for Locale, dynamic binding message bundle with arguments
 * Usage:
 * eXo.social.Locale.getLang(); the same as prefs.getLang();
 * eXo.social.Locale.getCountry(); the same as prefs.getCountry();
 * eXo.social.Locale.getMsg(key); the same as prefs.getMsg(key);
 * eXo.social.Locale.getMsg(key, args); dynamic binding argument to message bundle
 * @author  hoatle
 * @since   October 27, 2009
 * @copyright   eXo Platform
 </em>/</p>

<p>(function() {</p>

<pre><code>//prefs object to get lang, country, message bundle
var prefs;

/**
 * private function to lazily initialize prefs object
 */
function getPrefs() {
    if (!prefs) {
        prefs = new gadgets.Prefs();
    }
    return prefs;
}
/**
 * Class definition
 */
var Locale = function() {

}
/**
 * gets current lang
 * @static
 */
Locale.getLang = function() {
    prefs = getPrefs();
    return prefs.getLang();
}
/**
 * gets current country
 * @static
 */
Locale.getCountry = function() {
    prefs = getPrefs();
    return prefs.getCountry();
}
/**
 * alternative for prefs.getMsg(key)
 * uses to getMsg with provided key and substitute args
 *
 * eg: Test for {0}, {1}
 * If args does not match num of {\d}, warning and try to replace by corresponding index.
 * {0} should be replaced by args[0], etc.,
 * If args not provided, functions as prefs.getMsg(key)
 * @param   key String
 * @param   opt_args Array
 * @static
 */
Locale.getMsg = function(key, opt_args) {
    prefs = getPrefs();
    if (!key) {
        debug.warn('key is null!');
        return '';
    }
    var msg = prefs.getMsg(key);
    if (msg === '') {
        debug.warn('Can not find resource bundle with key = ' + key);
        return msg;
    }
    if (!opt_args) return msg;

    //checks if number of {\d} in msg matches opt_args.length
    var regex = /{\d+}/g;
    var matches = msg.match(regex);
    if (matches.length !== opt_args.length) {
        debug.warn("required " + matches.length + " args, provided: " + opt_args.length);
    }
    //substitutes by index: {0} in msg should be replaced by opt_args[0] and so on
    for (var i = 0, l = matches.length; i &lt; l; i++) {
        var index = matches[i].match(/\d+/g)[0];
        //TODO should improve performance
        var strToReplace = opt_args[index];
        if (!strToReplace) {
            debug.warn('matches[' + i + ']: ' + matches[i] + ' but no opt_args[' + index + ']');
        } else {
            msg = msg.replace(matches[i], opt_args[index]);
        }
    }
    return msg;
}
//Expose
window.eXo = window.eXo || {};
window.eXo.social = window.eXo.social || {};
window.eXo.social.Locale = Locale;
</code></pre>

<p>})();
```</p>

<p>Trong class trên không có gì đáng nói ngoài cách dùng regular expression để thay thế chuỗi với
pattern là <code>{0}, {1}, {2}</code> và lấy các index trong <code>{}</code> để thay bằng <code>opt_args[index]</code> tương ứng.
Bạn có thể xem thêm vài viết của <a href="http://twitter.com/sanglt">@sanglt</a>:
<a href="http://www.sanglt.com/content/su-dung-regular-expression-trong-javascript">Sử dụng regular expression trong JavaScript</a>.</p>

<ul>
<li>Chú ý: Class <code>eXo.social.Locale</code> dùng debug được @cowboy viết, đây là cách debug/log tuyệt vời và
tớ rất thích. Giờ trong tất cả các dự án hay ứng dụng nào tớ cũng dùng, sau này nhìn vào console là
biết lỗi gì ở đâu ngay, chứ dùng alert thì đúng là cực hình. Các bạn cũng nên sử dụng cách debug/log
này :).</li>
</ul>


<p>Download ứng dụng ví dụ đơn giản với cách thêm đối số vào &ldquo;message bundle&rdquo; tại
<a href="http://github.com/hoatle/opensocial/downloads">http://github.com/hoatle/opensocial/downloads</a></p>

<p>Mã nguồn tớ để ở đây: <a href="http://github.com/hoatle/opensocial/tree/master/message-bundle">http://github.com/hoatle/opensocial/tree/master/message-bundle</a></p>

<p>Đây là file ứng dụng xml:</p>

<p>```xml
&lt;?xml version=&ldquo;1.0&rdquo; encoding=&ldquo;UTF-8&rdquo;?>
<Module></p>

<pre><code>&lt;ModulePrefs title="Arguments Binding Message Bundle"
             description="Simple-App for arguments binding with message bundle"
             author_email="hoatlevan@gmail.com"
             author_affiliation="eXo Platform"&gt;
    &lt;Locale messages="locale/ALL_ALL.xml" /&gt;
    &lt;Locale lang="en" messages="locale/en_ALL.xml" /&gt;
    &lt;Locale lang="vi" messages="locale/vi_ALL.xml" /&gt;
    &lt;Require feature="opensocial-0.8" /&gt;
&lt;/ModulePrefs&gt;
&lt;Content type="html"&gt;
&lt;![CDATA[
    &lt;link rel="stylesheet" type="text/css" href="style/style.css" /&gt;
    &lt;script type="text/javascript" src="script/debug.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript" src="script/eXo/social/Locale.js"&gt;&lt;/script&gt;
    &lt;script type="text/javascript" src="script/app.js"&gt;&lt;/script&gt;
    &lt;p&gt;Resource bundle rendered by server: &lt;strong&gt;__MSG_hello_world__&lt;/strong&gt;&lt;/p&gt;
    &lt;p&gt;Resource bundle rendered by JavaScript:&lt;/p&gt;
    &lt;div id="helloMsg"&gt;&lt;/div&gt;
    &lt;div id="helloMsgArgs"&gt;&lt;/div&gt;
]]&gt;
&lt;/Content&gt;
</code></pre>

<p></Module>
```</p>

<p>Có thể thấy ở trên <code>__MSG_hello_world__</code> sẽ được thay thế bằng message bundle tương ứng với key là
&ldquo;hello_world&rdquo; (tớ để tất cả các file message bundle trong thư mục <code>locale</code>).</p>

<p>Để sử dụng class <code>eXo.social.Locale</code>, chúng ta có file app.js:</p>

<p>```javascript
function run() {</p>

<pre><code>var prefs = new gadgets.Prefs(),
    helloWorld = prefs.getMsg('hello_world');
alert(helloWorld); //"Hello world!" if current language is English
                   //"Chào thế giới!" if current language is Vietnamese

//eXo.social.Locale usage
var Locale = eXo.social.Locale;
var helloMsgEl = document.getElementById('helloMsg'),
    helloMsgArgsEl = document.getElementById('helloMsgArgs');

helloMsgEl.innerHTML = Locale.getMsg('hello_world');
helloMsgArgsEl.innerHTML = Locale.getMsg('hello_user_to_place', ['hoatle', 'Vietnam']);
</code></pre>

<p>}</p>

<p>gadgets.util.registerOnLoadHandler(run);
```</p>

<p>Bạn có thể chạy ứng dụng này ở bất kì OpenSocial container nào. Chúc bạn code vui :D.</p>

<p>Lưu ý: Có thể sử dụng OpenSocial templates để thêm đối số vào message bundle nhưng hiện nay hầu hết
các container chưa hỗ trợ hết.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Gán nhiều hàm xử lý sự kiện vào một phần tử trong JavaScript]]></title>
    <link href="http://blog.hoatle.info/2010/01/09/gan-nhieu-ham-xu-ly-su-kien-vao-mot-phan-tu-trong-javascript/"/>
    <updated>2010-01-09T02:06:00+00:00</updated>
    <id>http://blog.hoatle.info/2010/01/09/gan-nhieu-ham-xu-ly-su-kien-vao-mot-phan-tu-trong-javascript</id>
    <content type="html"><![CDATA[<p>Chiều nay đang lơ tơ mơ vì vừa ngủ trưa xong (bình thường không ngủ trưa thì thôi chứ cứ ngủ trưa
xong là lơ tơ mơ, chỉ muốn ngủ hết chiều cho sướng :d) thì có bạn hỏi trên group phpvietnam như
thế này:</p>

<p><strong>&ldquo;Em có một input có thuộc tính onclick="doSomeFunction();&rdquo; bây giờ muốn thêm
một hàm nữa ví dụ như onclick=&ldquo;doSomeFunction(); doSomeFunction2();&rdquo;. Công
việc này có làm bằng Javascript được không ah? Em cám ơn mọi người.&ldquo;</strong></p>

<p><em>Nguồn</em>: <a href="http://groups.google.com/group/phpvietnam/browse_thread/thread/c7a8688875a320c3">http://groups.google.com/group/phpvietnam/browse_thread/thread/c7a8688875a320c3</a></p>

<!-- more -->


<p>Trả lời bạn ý xong là hết cả buồn ngủ :P, tiện thể tối về viết lại kinh nghiệm cho cái blog đỡ
tủi thân :P. Khi xử lý sự kiện trong JavaScript có 4 mô hình đăng kí sự kiện được phát triển qua
thời gian. Tớ cũng nói thêm về cách sử dụng và xử lý ngữ cảnh (context) với từ khóa <code>this</code> trong các
hàm xử lý. Trong hàm xử lý phải làm sao đạt được 2 mục đích: truyền tham số vào hàm xử lý phải là
<code>event object</code> và từ khóa <code>this</code> trong hàm xử lý sự kiện đó phải là phần tử đã được đăng kí sự kiện.</p>

<p><strong>1. Inline Event Registration Model (Mô hình cổ xưa và quen thuộc nhất)</strong></p>

<p>Từ những ngày đầu khi có JavaScript và xử lý sự kiện thì chỉ có 1 cách duy nhất để gán hàm xử lý sự
kiện cho một phần tử và hiện nay nhiều người vẫn làm theo cách này. Đây là cách cổ xưa và nguyên
thủy nhất:</p>

<p><code>html
&lt;a href="#" onclick="doSomething();"&gt;link&lt;/a&gt;
</code></p>

<p>Mọi người đã quá quen với cách làm như trên, đặc biệt là từ khi viết những dòng code JavaScript đầu
tiên. Viết như vậy không có gì sai cả mà nó còn tiện, nhanh, dễ hiểu và ngày xưa đến nay người ta
vẫn làm thế đấy thôi :P. Tuy nhiên, khi JavaScript phát triển hơn thì cách tiếp cận khác đi chút vì
có nhiều vấn đề nảy sinh như: làm như trên không tách biệt cấu trúc (structure &ndash; html) và hành vi
(behavior &ndash; JavaScript), làm cho code rối tinh rối mù lên, nhất là khi bạn phải lấy dữ liệu AJAX về
rồi apply template vào thì rất mệt.</p>

<p>Ta có hàm xử lý sự kiện <code>doSomething</code> như sau:</p>

<p><code>javascript
function doSomething(evt) {
  alert(arguments[0]); // arguments[0] the same as evt
  alert(this);
}
</code></p>

<p>Với trường hợp này thì <code>evt</code> là <code>undefined</code> và <code>this</code> chính là <code>window object</code>. Giờ làm thế nào để
<code>evt</code> là <code>event object</code> và <code>this</code> là element thì làm theo cách sau:</p>

<p><code>html
&lt;a href="#" onclick="doSomething(event);"&gt;link&lt;/a&gt;
</code></p>

<p>Như này là đã truyền được <code>event</code> vào event handler rồi nhé. Theo tớ suy luận và thấy thì khi
element được <code>click</code> thì nó sẽ sinh ra sự kiện <code>onclick</code> như sau:</p>

<p><code>javascript
//[Native Code]
onclick(event) {
  //event handler được gọi theo cách này
  doSomething(event);
}
</code></p>

<p>Nhớ là phải để <code>event</code> là tham số của <code>doSomething(event)</code> chứ ko được dùng tên nào khác. Nếu dùng
tên <code>evt</code> chẳng hạn thì sẽ xảy ra <code>exeption</code> do:</p>

<p><code>javascript
[Native Code]
onclick(event) {
  //Gọi event handler mà có đối số là evt
  doSomething(evt); //Xảy ra exception ở đây vì evt là undefined.
}
</code></p>

<p>Đây là native code nên nó không cho <code>evt</code> là <code>undefined (null)</code> chứ trong các hàm bình thường thì
truyền tham số là <code>undefined (null)</code> thì không vấn đề gì, ko có exception gì hết :D.</p>

<p>Chú ý: đoạn code trên được test với chrome thì ko thấy lỗi mà vẫn chạy ầm ầm chứ IE, Firefox, Opera
đều xảy ra lỗi hết. Không biết nên chê hay khen bạn chrome đây :d.</p>

<p>Vậy là đến đây lấy được <code>event object</code> rồi, từ <code>event object</code> này lấy được rất nhiều thông tin khác
nhau như tên sự kiện, vị trí con trỏ chuột.v.v&hellip; (<code>evt.type</code>; <code>evt.charCode</code>&hellip;)</p>

<p>Giờ đến việc xử lý từ khóa <code>this</code> phải là element chứ không phải là <code>window object</code> làm như sau:</p>

<p><code>html
&lt;a href="#" onclick="doSomething.call(this, event)"&gt;link&lt;/a&gt;
</code></p>

<p>Khi đó trong Native Code sẽ là:</p>

<p><code>javascript
onclick(event) {
  //this ở đây là element
  doSomething.call(this, event);
}
</code></p>

<p>Trên chính là đoạn code hoàn chỉnh khi muốn lấy <code>this</code> và <code>event object</code>. Tớ nói kỹ ở đây thôi,
mấy đoạn sau sẽ không nói lại mấy cái này nữa.</p>

<p><strong>2. Traditional Event Registration Model</strong></p>

<p>Đây cũng là cách khá nhiều người làm khi bắt đầu muốn tách biệt giữa cấu trúc và hành vi trên trang
web. Trong code JavaScript sẽ đăng kí hàm xử lý sự kiện còn html thì chỉ là html mà thôi.</p>

<p><code>html
&lt;a href="#" id="mylink"&gt;link&lt;/a&gt;
</code></p>

<p>Sau đó trong JavaScript đợi dom load hết thì cho đoạn code sau được thực thi:</p>

<p><code>javascript
var linkEl = document.getElementById('myLink');
linkEl.onclick = function() {
  doSomething();
}
</code></p>

<p>Đây là cách truyền thống được dùng cũng không phải là ít và hiện nay nó tương thích trên tất cả các
trình duyệt lớn nên ko có gì đáng ngại cả :). Trong mô hình này thì <code>event object</code> sẽ được truyền
luôn vào hàm xử lý sự kiện, còn <code>this</code> trong hàm xử lý sự kiện cũng là element luôn :D.</p>

<p>Có thể làm thế này khi trong hàm <code>doSomething</code> muốn có <code>event object</code> và <code>this</code> là phần tử sinh ra
sự kiện.</p>

<p><code>javascript
linkEl.onclick = function(evt) {
  doSomething.call(this,evt);
}
</code></p>

<p>Trong trường hợp <code>doSomething</code> nhận thêm vài tham số thì nên viết như này:</p>

<p>```javascript
function doSomething(evt, param1, param2) {
//code implementation
}</p>

<p>linkEl.onclick = function(evt) {
  var param1, param2;
  doSomething.call(this, evt, param1, param2);
  // Giống với: doSomething.apply(this, [evt, param1, param2]);
}
```</p>

<p>Tiếp đến là mô hình thứ 3 và 4 trong xử lý sự kiện. W3C model và Microsoft (IE) model. Sau đó kết
hợp hai mô hình 3 và 4 này được giải pháp khá hoàn chỉnh và có thể sử dụng ngon lành đối với mọi
trình duyệt lớn :).</p>

<p><strong>3. W3C Event Registration Model</strong></p>

<p>Theo mô hình chuẩn của bạn W3C thì đây là cách đăng kí sự kiện cho một element, có thể đăng kí
cùng lúc nhiều hàm xử lý cho 1 element:</p>

<p><code>javascript
element.addEventListener(eventType, listener, useCapture);
</code></p>

<p><code>eventType</code> ở đây có thể là: click, mouseover, mouseout.v.v&hellip;</p>

<p><code>listener</code> chính là hàm xử lý sự kiện được thực thi khi có sự kiện <code>eventType</code> xảy ra.</p>

<p><code>useCapture</code> bạn nên để là <code>false</code> để thống nhất với trình duyệt IE, cái này liên quan tới event
phase mà tớ sẽ nói sau vào một bài viết khác.</p>

<p>Giờ có thể sử dụng như sau:</p>

<p><code>html
&lt;a href="#" id="mylink"&gt;link&lt;/a&gt;
</code></p>

<p>```javascript
//javascript, chỉ chạy trên các trình duyệt Firefox, Opera, Chrome
// ko chạy được trên IE
var linkEl = document.getElementById(&lsquo;myLink&rsquo;);
linkEl.addEventListener(&lsquo;click&rsquo;, function() {</p>

<pre><code>alert(arguments[0]); //event object
alert(this); //linkEl
</code></pre>

<p>}, false);
```</p>

<p>Rất may là <code>event object</code> lại được truyền và <code>this</code> trỏ luôn đến element nên có thể gọi
<code>doSomething</code> luôn:</p>

<p>```javascript
linkEl.addEventListener(&lsquo;click&rsquo;, function(evt) {</p>

<pre><code>doSomething.call(this, evt);
</code></pre>

<p>}, false);
```</p>

<p>Với cách này bạn có thể add bao nhiêu hàm xử lý sự kiện tùy ý, khi có 1 sự kiện xảy ra thì các hàm
xử lý sự kiện đã đăng kí sẽ được thực thi và theo W3C đưa ra thì các hàm này thực thi có thể không
theo thứ tự đăng kí và hiện tại bạn không thể gọi phương thức nào của element để kiểm tra xem sự
kiện nào đó có bao nhiêu hàm xử lý sự kiện đã được đăng kí.</p>

<p>Nhưng muốn bỏ một hàm xử lý đăng kí sự kiện thì làm thế nào? Có luôn:</p>

<p>```javascript</p>

<pre><code>element.removeEventListener(eventType, listener, useCapture);
</code></pre>

<p>```</p>

<p>Cái này rất hiếm khi dùng. Khi muốn <code>remove</code> được một <code>listener</code> nào thì <code>listener</code> đó phải có tên.
Cách <code>add</code> của tớ ở trên kia dùng <code>anonymouse function</code> thì không thể <code>remove</code> được. Muốn <code>remove</code>
được thì phải làm theo cách này:</p>

<p><code>javascript
var myListener = function() {
  alert(arguments[0]);
  alert(this);
 //cho chạy một lần đầu rồi remove listener đi luôn
  this.removeEventListener('click', myListener, false);
}
linkEl.addEventListener('click', myListener, false);
</code></p>

<p>Đấy là theo W3C, còn Microsoft lại làm theo cách khác.</p>

<p><strong>4. Microsoft Event Registration Model</strong></p>

<p>Bạn IE thì lại chơi kiểu khác, bạn ý không dùng <code>addEventListener</code> mà lại dùng:</p>

<p>```javascript</p>

<pre><code>element.attachEvent(onEventType, handler);
</code></pre>

<p>```</p>

<p>Ví dụ:</p>

<p><code>javascript
var linkEl = document.getElementById('myLink');
//Chỉ chạy trên IE
linkEl.attachEvent('onclick', function() {
  alert(arguments[0]); //event object
  alert(this); //linkEl
})
</code></p>

<p>Muốn remove một handler (listener) thì dùng <code>detachEvent</code> cũng làm tương tự giống mô hình W3C ở trên:</p>

<p><code>javascript
var myListener = function(evt) {
  alert(evt);
  alert(this);
  this.detachEvent('onclick', myListener);
}
</code></p>

<p>Chú ý vì IE không có 2 event phase là <code>capture</code> và <code>bubble</code> mà chỉ có <code>bubble</code> phase nên khi sử dụng
với mô hình của W3C thì luôn dùng <code>false</code> với <code>useCapture</code> cho an toàn, nếu hiểu kỹ sự khác biệt của
2 phase này và có mục đích thì mới nên dùng <code>true</code>.</p>

<p><strong>5. Cuối cùng là cách kết hợp mô hình W3C với M$ (IE) thì ta có thể thiết kế và sử api đơn giản như sau:</strong></p>

<p><code>javascript
addEventListener(element, eventType, listener, useCapture);
removeEventListener(element, eventType, listener, useCapture);
</code></p>

<p>Phải luôn giữ <code>event object</code> được truyền vào tham số của listener và từ khóa this trong listener
phải trỏ đến element. Code như sau:</p>

<p>```javascript
/<em>*
 * Cross browser add event listener method. For &lsquo;evt&rsquo; pass a string value with the leading &ldquo;on&rdquo; omitted
 * e.g. addEventListener(window,&lsquo;load&rsquo;,myFunctionNameWithoutParenthesis,false);
 * @param    obj object to attach event
 * @param    evt event name: click, mouseover, focus, blur&hellip;
 * @param    func    function name
 * @param    useCapture    true or false; if false => use bubbling
 * @static
 * @see        <a href="http://phrogz.net/JS/AttachEvent_js.txt">http://phrogz.net/JS/AttachEvent_js.txt</a>
 </em>/
 function addEventListener(obj, evt, fnc, useCapture) {</p>

<pre><code>if (obj === null || evt === null || fnc ===  null || useCapture === null) {
   alert('all params are required for addEventListener');
    return;
}
if (!useCapture) useCapture = false;
if (obj.addEventListener){
    obj.addEventListener(evt, fnc, useCapture);
} else if (obj.attachEvent) {
    obj.attachEvent('on'+evt, function(evt) {
        fnc.call(obj, evt);
    });
} else{
    myAttachEvent(obj, evt, fnc);
    obj['on'+evt] = function() { myFireEvent(obj,evt) };
}
//The following are for browsers like NS4 or IE5Mac which don't support either
//attachEvent or addEventListener
var myAttachEvent = function(obj, evt, fnc) {
    if (!obj.myEvents) obj.myEvents={};
    if (!obj.myEvents[evt]) obj.myEvents[evt]=[];
    var evts = obj.myEvents[evt];
    evts[evts.length] = fnc;
}
var myFireEvent = function(obj, evt) {
    if (!obj || !obj.myEvents || !obj.myEvents[evt]) return;
    var evts = obj.myEvents[evt];
    for (var i=0,len=evts.length;i&lt;len;i++) evts[i]();
}
</code></pre>

<p>}
/<em>*
 * removes event listener.
 * @param    obj element
 * @param    evt event name, &lsquo;click&rsquo;, &lsquo;blur&rsquo;. &lsquo;focus&rsquo;&hellip;
 * @func    function name to be removed if found
 * @useCapture true or false; false &ndash;> bubbling event phase
 * @static
 * //TODO make sure method cross-browsered
 </em>/
 function removeEventListener(obj, evt, func, useCapture) {</p>

<pre><code>if (obj.removeEventListener) {
    obj.removeEventListener(evt, func, useCapture);
} else if (obj.detachEvent) {//IE
    obj.detachEvent('on'+evt, func);
}
</code></pre>

<p>}
```</p>

<p>Khi đó cách sử dụng đơn giản như sau:</p>

<p>```javascript
  var linkEl = document.getElementById(&lsquo;myLink&rsquo;);
  addEventListener(&lsquo;click&rsquo;, function(evt) {</p>

<pre><code>doSomething.call(this, evt);
</code></pre>

<p>  }, false);
```</p>

<p>Hy vọng tớ sẽ sớm viết thêm về event phase sau, chúc bạn code vui :D.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Tổng kết năm 2009 và những dự định cho năm 2010]]></title>
    <link href="http://blog.hoatle.info/2009/12/31/tong-ket-nam-2009-va-nhung-du-dinh-cho-nam-2010/"/>
    <updated>2009-12-31T00:41:00+00:00</updated>
    <id>http://blog.hoatle.info/2009/12/31/tong-ket-nam-2009-va-nhung-du-dinh-cho-nam-2010</id>
    <content type="html"><![CDATA[<p>Hic, lâu lắm rồi ko viết blog, cũng vì lười, cũng vì bận nữa. Nhưng bắt đầu từ bây giờ, lại khoái
viết lại rồi, có nhiều thứ chia sẻ hơn, dù bận gì thì bận cũng sẽ phải cố viết đều đặn hơn. 8 tháng
không động đến blog, giờ ngồi mãi mới nặn ra được vài chữ. Mà tiếng Anh thì kém hẳn, bí từ kinh
khủng mà đấy là còn chưa thi xong tốt nghiệp :SS. Trong bài viết này sẽ điểm lại một số điểm nổi
bật của năm qua mà đáng lẽ những điểm này sẽ là một bài blog cơ :(.</p>

<!-- more -->


<ul>
<li><p>Tháng 2: Giữa tháng 2 bắt đầu vào làm part-time ở eXo Platform. Đầu tiên là Document Writer, sau
đó thì tham gia eXo Social team, vào làm lơ tơ mơ, nhưng giờ cũng đỡ hơn rồi :d.</p></li>
<li><p>Tháng 4: Cùng tổ chức Barcamp Hanoi 2009 với @xoai, @forty4vn, @dac2205 và bạn của @xoai bên RMIT.
Đây là lần đầu tiên tớ tham gia tổ chức một sự kiện như thế, được gặp gỡ, giao lưu với những người
có kinh nghiệm thật là thích :d. Ở Barcamp Hanoi, tớ nói về &ldquo;OpenSocial&rdquo;. OpenSocial được sử dụng ở
hầu hết các mạng xã hội lớn (trừ facebook ko theo chuẩn này), hiện nay như tớ được biết thì ở Việt
Nam có tamtay.vn và me.zing.vn đang phát triển theo chuẩn này. Còn bên eXo Social cũng đang phát
triển sản phẩm theo chuẩn này.</p></li>
<li><p>Tháng 11: Cùng anh @tuanchip (eXo CS team leader), anh Nam (CS team), chị Thủy (phòng marketing và
truyền thông), anh Việt (trưởng phòng nhân sự) giới thiệu OpenSocial và eXo Platform ở 3 trung tâm
lập trình FPT-Aptech, mục đích là giới thiệu công nghệ, tìm kiếm nhân sự, giới thiệu công ty để
các bạn định hướng về công nghệ để sau này nếu muốn làm việc ở eXo thì nên biết và tìm hiểu những
gì là cần thiết.</p></li>
<li><p>Tháng 12:</p>

<ul>
<li><p>Lần đầu tiên vào Xì-Gòn tham dự Barcamp Saigon. Vui phết, tớ vào đấy 3 ngày, thanks anh
@jishanvn đã cho ở nhờ 3 ngày :D. Ở đấy tớ nói về &ldquo;Advanced JavaScript Techniques&rdquo;.</p></li>
<li><p>Lần thứ 2 tham gia Hanoi PHP Day, lần trước thì đến nghe thôi chứ ko nói, lần này thì nói về
&ldquo;Advanced JavaScript Techniques&rdquo;, tớ chuẩn bị chủ đề này cho cả Barcamp Saigon và Hanoi PHP Day
mà :d, tuy nhiên 2 bài nói thì không giống nhau hoàn toàn đâu ;).</p></li>
</ul>
</li>
</ul>


<p>Đấy là một số điểm nổi bật của năm 2009, sang năm mới 2010 hy vọng sẽ tham gia được nhiều sự kiện
thú vị nữa, được giao lưu anh em nhiều hơn. Sang tháng 1 hy vọng thi tốt nghiệp suôn sẻ để được tự
do bay nhảy :d.</p>

<ul>
<li><p>Đầu năm hy vọng có 1 buổi offline một số anh em IT để nhậu + chém gió (Hanoi Hacker Happy Hour).</p></li>
<li><p>Hy vọng lại có Barcamp Hanoi tiếp, eXo sẽ tài trợ tiếp luôn :d.</p></li>
<li><p>Sau khi tốt nghiệp sẽ âm thầm phát triển 1 cái gì đó :D.</p></li>
<li><p>&hellip;</p></li>
</ul>


<p>Đầu tư khá nhiều sức vào project để bảo vệ ở Hanoi Aptech (cùng @huydung) nhưng cuối cùng đuối :((,
sau đấy chưa lấy lại được tinh thần để làm tiếp :|.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Làm việc cho eXo Platform hay Google đây?]]></title>
    <link href="http://blog.hoatle.info/2009/04/01/lam-viec-cho-exo-platform-hay-google-day/"/>
    <updated>2009-04-01T22:35:00+00:00</updated>
    <id>http://blog.hoatle.info/2009/04/01/lam-viec-cho-exo-platform-hay-google-day</id>
    <content type="html"><![CDATA[<p><strong>Chú ý: Đây là bài viết trêu đùa ngày Cá Tháng Tư</strong></p>

<p>Tớ đã suy nghĩ rất nhiều. Chả là bên phía Google có đề nghị tớ qua làm việc (full-time) ở Singapore
trong vòng 2 năm sau vụ ứng dụng OpenSocial của tớ (Music-Engine) đạt giải nhì trong cuộc thi viết
ứng dụng OpenSocial khu vực Đông Nam Á do Google tổ chức. Tuy nhiên, không hiểu lý do phức tạp gì
về vụ hải quan mà tớ không thể nhận được Ipod Touch như trong phần thưởng đã ghi, thay vào đó sẽ
nhận được tiền mặt :(. Shannon Madison (là người chịu trách nhiệm chính của cuộc thi) và tớ gần đây
đã bàn luận nhiều về cơ hội việc làm này. Chị ý bảo rằng một số nhân viên của Google sẽ tham gia
BarCamp Hanoi 2009 này và sẽ hé lộ cho chúng ta biết về chiến lược của Google ở Đông Nam Á nói chung
và Việt Nam nói riêng. Giờ thì tớ phải chọn: làm việc bán thời gian ở eXo Platform hay làm việc toàn
thời gian cho Google ở Singapore trong vòng 2 năm.</p>

<!-- more -->


<p>Làm việc cho Google là một cơ hội tốt và hiếm có cho tương lai của tớ. Shannon cũng có nói về kế
hoạch văn phòng đại diện của Google ở Việt Nam, so vậy nếu tớ làm việc cho Google ở Singapore xong
2 năm thì có thể trở lại Việt Nam để làm ở văn phòng đại diện của Google ở Việt Nam. Tớ biết, đây
là cơ hội rất tốt và hiếm hoi đê tớ có thể thử sức mình khi làm việc ở nước ngoài và lại là làm việc
cho Google nữa chứ, sẽ tuyệt vời lắm chứ! Tuy nhiên, nếu tớ đồng ý làm việc ở Sing, điều đó có nghĩa
là tớ phải ngừng việc học của mình ở HUT, nghĩa là tớ phải rờ xa gia đình, bạn bè và những kỷ niệm
đẹp để đến đó làm việc. Thực sự tớ chưa bao giờ ra nước ngoài cả, nếu được vậy thì còn gì bằng.</p>

<p>Tuy nhiên cũng không phải là không có khúc mắc. Tớ vừa mới làm việc ở eXo Platform được có 1 tháng
rưỡi. Mọi thứ mới chỉ là bắt đầu và thực sự thì tớ chưa đạt được điều gì ở eXo Platform cả. Tớ đã
cố gắng nhiều để được làm việc nơi đây. Chỉ sau một thời gian ngắn ngủi như vậy thôi thì tớ biết eXo
Platform chính là môi trường tốt nhất ở Hà Nội này để cho tớ học tập, làm việc và có những người bạn
tốt. Mọi người ở đây thật tốt, dường như tớ đã quen hết với mọi người rồi. Mọi người đã chia sẻ với
nhau rất nhiều, nhất là trong các vụ: tiệc tùng đám cưới, chia tay (Jeremi), karaoke. Ngoài ra thì
tớ cũng muốn tìm hiểu về eXo Platform sau đó áp dụng vào project cuối cùng ở Hanoi Aptech sau đó là
tốt nghiệp.</p>

<p>Giờ nếu tớ đồng ý sang Sing làm việc cho Google thì tớ phải từ bỏ nhiều thứ ở nơi đây. Nếu không thì
tớ vẫn làm việc ở eXo Platform bình thường. Trời ơi!!! Làm thế nào bây giờ? Giá mà làm việc ở eXo
Platform được 1 thời gian sau đó rồi mới nhận được lời đề nghị của Google có phải tốt hơn không. Tớ
phải làm sao giờ, ai có thể cho tớ lời khuyên đúng đắn không :(?</p>
]]></content>
  </entry>
  
</feed>
