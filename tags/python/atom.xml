<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: python | blog.hoatle.info]]></title>
  <link href="http://blog.hoatle.info/tags/python/atom.xml" rel="self"/>
  <link href="http://blog.hoatle.info/"/>
  <updated>2013-12-25T23:48:05+00:00</updated>
  <id>http://blog.hoatle.info/</id>
  <author>
    <name><![CDATA[hoatle]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Dùng "decorator" để đo thời gian thực thi của bất kỳ hàm nào trong Python]]></title>
    <link href="http://blog.hoatle.info/2013/12/25/dung-decorator-de-do-thoi-gian-thuc-thi-cua-bat-ky-ham-nao-trong-python/"/>
    <updated>2013-12-25T20:09:00+00:00</updated>
    <id>http://blog.hoatle.info/2013/12/25/dung-decorator-de-do-thoi-gian-thuc-thi-cua-bat-ky-ham-nao-trong-python</id>
    <content type="html"><![CDATA[<p><img class="center" src="/images/2013/12/python-logo-master.png" title="Python Logo" ></p>

<p>Python có cú pháp cho &ldquo;decorator&rdquo; rất linh hoạt, nó được sử dụng khá linh hoạt.
Bài viết này tôi giới thiệu cách sử dụng 1 ví dụ về &ldquo;decorator&rdquo; khá hay để đo
đếm thời gian thực thi của bất kỳ hàm nào.</p>

<!-- more -->


<h2>&ldquo;decorator&rdquo; là gì?</h2>

<p>Bạn đừng nhầm lẫn &ldquo;decorator&rdquo; trong Python với &ldquo;decorator design pattern&rdquo;<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>
vì nó còn làm được nhiều hơn thế, nó nghiêng về &ldquo;AOP (Aspect Oriented
Programming)&rdquo;<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup> hơn.</p>

<p>Để tìm hiểu nhiều hơn về &ldquo;decorator&rdquo; trong Python, bạn có thể xem các bài viết
trong phần đọc thêm bên dưới.</p>

<h2>Yêu Cầu</h2>

<p>Đo thời gian thực thi của hàm sau (theo mili-giây):</p>

<p>```python
def add(x, y):</p>

<pre><code>return x + y
</code></pre>

<p>```</p>

<p>Lưu tệp tin là: &ldquo;add.py&rdquo;.</p>

<h2>Đo thời gian đơn giản nhất</h2>

<p>Để đo thời gian thực thi, cách đơn giản nhất là đếm thời gian trước lúc chạy và
sau khi chạy xong hàm, rồi lấy thời gian sau trừ thời gian trước cho khoảng
thời gian thực thi.</p>

<p>Có thể viết như sau:</p>

<p>```python
import time</p>

<p>def add(x, y):</p>

<pre><code>return x + y
</code></pre>

<h1>test</h1>

<p>start_time = time.time()
add(3, 4)
end_time = time.time()
print &lsquo;total run-time: %f ms&rsquo; % ((end_time &ndash; start_time) * 1000)
```</p>

<p>Sau khi chạy <code>$ python add.py</code> có kết quả tương tự như sau:</p>

<p><code>bash
$ python add.py
total run-time: 0.007153 ms
</code></p>

<p>Đấy là cách đo đơn giản nhất mà có thể làm được với bất kỳ ngôn ngữ nào, nhưng
cách đo đếm này không hiệu quả khi cần đo đếm hàng nghìn hàm, code sẽ bị trùng
lặp nhiều (&ldquo;boiler plate&rdquo;).</p>

<h2>Dùng &ldquo;decorator design pattern&rdquo;</h2>

<p>Trong Python, có thể làm như sau:</p>

<p>```python
import time</p>

<p>def timer(fn):</p>

<pre><code>def wrapper(*args, **kwargs):
    start_time = time.time()
    result = fn(*args, **kwargs)
    end_time = time.time()
    print 'total run-time of %r: %f ms' % (fn.__name__, (end_time - start_time) * 1000)
    return result
return wrapper
</code></pre>

<p>def add(x, y):</p>

<pre><code>return x + y
</code></pre>

<p>add = timer(add)</p>

<p>def sub(x, y):</p>

<pre><code>return x - y
</code></pre>

<p>sub = timer(sub)</p>

<h1>test</h1>

<p>add(3, 4)
sub(3, 4)
```</p>

<p>Kết quả chạy có thể như sau:</p>

<p><code>bash
$ python add.py
total run-time of 'add': 0.143051 ms
total run-time of 'sub': 3.393173 ms
</code></p>

<p>Đây là cách làm thường thấy trước khi cú pháp &ldquo;decorator&rdquo; được giới thiệu, có
thể dùng <code>timer</code> để đo đếm các hàm, ví dụ <code>add</code> và <code>sub</code> như ví dụ trên.</p>

<h2>Dùng cú pháp &ldquo;decorator&rdquo;</h2>

<p>Rất đơn giản, thay vì <code>add = timer(add)</code> mà dùng <code>@timer</code>:</p>

<p>```python
import time</p>

<p>def timer(fn):</p>

<pre><code>def wrapper(*args, **kwargs):
    start_time = time.time()
    result = fn(*args, **kwargs)
    end_time = time.time()
    print 'total run-time of %r: %f ms' % (fn.__name__, (end_time - start_time) * 1000)
    return result
return wrapper
</code></pre>

<p>@timer
def add(x, y):</p>

<pre><code>return x + y
</code></pre>

<p>@timer
def sub(x, y):</p>

<pre><code>return x - y
</code></pre>

<h1>test</h1>

<p>add(3, 4)
sub(3, 4)
```</p>

<p>Như vậy bằng việc dùng &ldquo;decorator&rdquo;, code Python dễ đọc hơn, lưu ý bạn có thể
thêm nhiều &ldquo;decorator&rdquo; cho 1 hàm.</p>

<h2>Ứng dụng <code>timer</code></h2>

<p>Đo đếm thời gian liên quan đến &ldquo;performance-tuning&rdquo; và &ldquo;timeout&rdquo; &ndash; giới hạn
thời gian thực thi của hàm, nếu lâu quá thì thông báo lỗi và phải xử lý. Ví dụ
chỉ cho hàm <code>add</code> trên được thực thi trong khoảng <code>0.007 ms</code> thì làm như sau:</p>

<p>```python
import sys
import time</p>

<p>class TimeoutException(Exception):</p>

<pre><code>pass
</code></pre>

<p>def timeout(val=sys.maxsize, info=False):</p>

<pre><code>def wrapper(fn):
    def wrapper_fn(*args, **kwargs):
        start_time = time.time()
        result = fn(*args, **kwargs)
        end_time = time.time()
        run_time = (end_time - start_time) * 1000 # miliseconds
        if val &lt; run_time:
            raise TimeoutException('%r run-time: expected: %f ms, but actual: %f ms' % (fn.__name__, val, run_time))
        if info:
            print '%r run-time: %f ms' % (fn.__name__, run_time)
        return result
    return wrapper_fn
return wrapper
</code></pre>

<p>@timeout(0.007)
def add(x, y):</p>

<pre><code>return x + y
</code></pre>

<p>@timeout(info=True)
def sub(x, y):</p>

<pre><code>return x - y
</code></pre>

<h1>Test</h1>

<p>add(3, 4)</p>

<p>sub(3, 4)
```</p>

<p><code>timeout</code> nhận 2 tham số là <code>val</code> &ndash; giá trị &ldquo;timeout&rdquo; và in ra thông tin thời
gian chạy với tham số <code>info</code>.</p>

<p>Khi thời gian thực thi của <code>add</code> quá 0.007 mili-giây sẽ xảy ra
<code>TimeoutException</code> tương tự như lần chạy sau:</p>

<p>```bash
$ python add.py
Traceback (most recent call last):
  File &ldquo;test.py&rdquo;, line 35, in <module></p>

<pre><code>add(3, 4)
</code></pre>

<p>  File &ldquo;test.py&rdquo;, line 17, in wrapper_fn</p>

<pre><code>raise TimeoutException('%r run-time: expected: %f ms, but actual: %f ms' % (fn.__name__, val, run_time))
</code></pre>

<p><strong>main</strong>.TimeoutException: &lsquo;add&rsquo; run-time: expected: 0.007000 ms, but actual: 0.137091 ms
```</p>

<h2>Tổng Kết</h2>

<p>Như vậy bạn có thể quản lý và đưa giới hạn thời gian thực thi cho bất kỳ hàm
nào, điều này khá quan trọng với vấn đề &ldquo;performance&rdquo; cũng như &ldquo;security&rdquo; nhờ
cách dùng &ldquo;decorator&rdquo; rất linh hoạt trong Python. Đây chỉ là một ứng dụng nho
nhỏ của &ldquo;decorator&rdquo;, chúc bạn có thể áp dụng &ldquo;decorator&rdquo; trong nhiều bài
toán thực tế hơn.</p>

<h2>Đọc Thêm</h2>

<ul>
<li><a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240808">http://www.artima.com/weblogs/viewpost.jsp?thread=240808</a></li>
<li><a href="http://www.artima.com/weblogs/viewpost.jsp?thread=240845">http://www.artima.com/weblogs/viewpost.jsp?thread=240845</a></li>
<li><a href="http://en.wikipedia.org/wiki/Python_syntax_and_semantics#Decorators">http://en.wikipedia.org/wiki/Python_syntax_and_semantics#Decorators</a></li>
</ul>


<h2>Hình Ảnh</h2>

<ul>
<li><a href="http://www.vizteams.com/blog/why-python-as-programming-language-past-present-future">http://www.vizteams.com/blog/why-python-as-programming-language-past-present-future</a></li>
</ul>

<div class="footnotes">
<hr/>
<ol>
<li id="fn:1">
<p>http://en.wikipedia.org/wiki/Decorator_pattern<a href="#fnref:1" rev="footnote">&#8617;</a></p></li>
<li id="fn:2">
<p>http://en.wikipedia.org/wiki/Aspect-oriented_programming<a href="#fnref:2" rev="footnote">&#8617;</a></p></li>
</ol>
</div>

]]></content>
  </entry>
  
</feed>
