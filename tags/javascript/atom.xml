<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: JavaScript | blog.hoatle.info]]></title>
  <link href="http://blog.hoatle.info/tags/javascript/atom.xml" rel="self"/>
  <link href="http://blog.hoatle.info/"/>
  <updated>2013-12-06T08:51:21+00:00</updated>
  <id>http://blog.hoatle.info/</id>
  <author>
    <name><![CDATA[hoatle]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Gán nhiều hàm xử lý sự kiện vào một phần tử trong JavaScript]]></title>
    <link href="http://blog.hoatle.info/2010/01/09/gan-nhieu-ham-xu-ly-su-kien-vao-mot-phan-tu-trong-javascript/"/>
    <updated>2010-01-09T02:06:00+00:00</updated>
    <id>http://blog.hoatle.info/2010/01/09/gan-nhieu-ham-xu-ly-su-kien-vao-mot-phan-tu-trong-javascript</id>
    <content type="html"><![CDATA[<p>Chiều nay đang lơ tơ mơ vì vừa ngủ trưa xong (bình thường không ngủ trưa thì thôi chứ cứ ngủ trưa
xong là lơ tơ mơ, chỉ muốn ngủ hết chiều cho sướng :d) thì có bạn hỏi trên group phpvietnam như
thế này:</p>

<p><strong>&ldquo;Em có một input có thuộc tính onclick="doSomeFunction();&rdquo; bây giờ muốn thêm
một hàm nữa ví dụ như onclick=&ldquo;doSomeFunction(); doSomeFunction2();&rdquo;. Công
việc này có làm bằng Javascript được không ah? Em cám ơn mọi người.&ldquo;</strong></p>

<p><em>Nguồn</em>: <a href="http://groups.google.com/group/phpvietnam/browse_thread/thread/c7a8688875a320c3">http://groups.google.com/group/phpvietnam/browse_thread/thread/c7a8688875a320c3</a></p>

<!-- more -->


<p>Trả lời bạn ý xong là hết cả buồn ngủ :P, tiện thể tối về viết lại kinh nghiệm cho cái blog đỡ
tủi thân :P. Khi xử lý sự kiện trong JavaScript có 4 mô hình đăng kí sự kiện được phát triển qua
thời gian. Tớ cũng nói thêm về cách sử dụng và xử lý ngữ cảnh (context) với từ khóa <code>this</code> trong các
hàm xử lý. Trong hàm xử lý phải làm sao đạt được 2 mục đích: truyền tham số vào hàm xử lý phải là
<code>event object</code> và từ khóa <code>this</code> trong hàm xử lý sự kiện đó phải là phần tử đã được đăng kí sự kiện.</p>

<p><strong>1. Inline Event Registration Model (Mô hình cổ xưa và quen thuộc nhất)</strong></p>

<p>Từ những ngày đầu khi có JavaScript và xử lý sự kiện thì chỉ có 1 cách duy nhất để gán hàm xử lý sự
kiện cho một phần tử và hiện nay nhiều người vẫn làm theo cách này. Đây là cách cổ xưa và nguyên
thủy nhất:</p>

<p><code>html
&lt;a href="#" onclick="doSomething();"&gt;link&lt;/a&gt;
</code></p>

<p>Mọi người đã quá quen với cách làm như trên, đặc biệt là từ khi viết những dòng code JavaScript đầu
tiên. Viết như vậy không có gì sai cả mà nó còn tiện, nhanh, dễ hiểu và ngày xưa đến nay người ta
vẫn làm thế đấy thôi :P. Tuy nhiên, khi JavaScript phát triển hơn thì cách tiếp cận khác đi chút vì
có nhiều vấn đề nảy sinh như: làm như trên không tách biệt cấu trúc (structure &ndash; html) và hành vi
(behavior &ndash; JavaScript), làm cho code rối tinh rối mù lên, nhất là khi bạn phải lấy dữ liệu AJAX về
rồi apply template vào thì rất mệt.</p>

<p>Ta có hàm xử lý sự kiện <code>doSomething</code> như sau:</p>

<p><code>javascript
function doSomething(evt) {
  alert(arguments[0]); // arguments[0] the same as evt
  alert(this);
}
</code></p>

<p>Với trường hợp này thì <code>evt</code> là <code>undefined</code> và <code>this</code> chính là <code>window object</code>. Giờ làm thế nào để
<code>evt</code> là <code>event object</code> và <code>this</code> là element thì làm theo cách sau:</p>

<p><code>html
&lt;a href="#" onclick="doSomething(event);"&gt;link&lt;/a&gt;
</code></p>

<p>Như này là đã truyền được <code>event</code> vào event handler rồi nhé. Theo tớ suy luận và thấy thì khi
element được <code>click</code> thì nó sẽ sinh ra sự kiện <code>onclick</code> như sau:</p>

<p><code>javascript
//[Native Code]
onclick(event) {
  //event handler được gọi theo cách này
  doSomething(event);
}
</code></p>

<p>Nhớ là phải để <code>event</code> là tham số của <code>doSomething(event)</code> chứ ko được dùng tên nào khác. Nếu dùng
tên <code>evt</code> chẳng hạn thì sẽ xảy ra <code>exeption</code> do:</p>

<p><code>javascript
[Native Code]
onclick(event) {
  //Gọi event handler mà có đối số là evt
  doSomething(evt); //Xảy ra exception ở đây vì evt là undefined.
}
</code></p>

<p>Đây là native code nên nó không cho <code>evt</code> là <code>undefined (null)</code> chứ trong các hàm bình thường thì
truyền tham số là <code>undefined (null)</code> thì không vấn đề gì, ko có exception gì hết :D.</p>

<p>Chú ý: đoạn code trên được test với chrome thì ko thấy lỗi mà vẫn chạy ầm ầm chứ IE, Firefox, Opera
đều xảy ra lỗi hết. Không biết nên chê hay khen bạn chrome đây :d.</p>

<p>Vậy là đến đây lấy được <code>event object</code> rồi, từ <code>event object</code> này lấy được rất nhiều thông tin khác
nhau như tên sự kiện, vị trí con trỏ chuột.v.v&hellip; (<code>evt.type</code>; <code>evt.charCode</code>&hellip;)</p>

<p>Giờ đến việc xử lý từ khóa <code>this</code> phải là element chứ không phải là <code>window object</code> làm như sau:</p>

<p><code>html
&lt;a href="#" onclick="doSomething.call(this, event)"&gt;link&lt;/a&gt;
</code></p>

<p>Khi đó trong Native Code sẽ là:</p>

<p><code>javascript
onclick(event) {
  //this ở đây là element
  doSomething.call(this, event);
}
</code></p>

<p>Trên chính là đoạn code hoàn chỉnh khi muốn lấy <code>this</code> và <code>event object</code>. Tớ nói kỹ ở đây thôi,
mấy đoạn sau sẽ không nói lại mấy cái này nữa.</p>

<p><strong>2. Traditional Event Registration Model</strong></p>

<p>Đây cũng là cách khá nhiều người làm khi bắt đầu muốn tách biệt giữa cấu trúc và hành vi trên trang
web. Trong code JavaScript sẽ đăng kí hàm xử lý sự kiện còn html thì chỉ là html mà thôi.</p>

<p><code>html
&lt;a href="#" id="mylink"&gt;link&lt;/a&gt;
</code></p>

<p>Sau đó trong JavaScript đợi dom load hết thì cho đoạn code sau được thực thi:</p>

<p><code>javascript
var linkEl = document.getElementById('myLink');
linkEl.onclick = function() {
  doSomething();
}
</code></p>

<p>Đây là cách truyền thống được dùng cũng không phải là ít và hiện nay nó tương thích trên tất cả các
trình duyệt lớn nên ko có gì đáng ngại cả :). Trong mô hình này thì <code>event object</code> sẽ được truyền
luôn vào hàm xử lý sự kiện, còn <code>this</code> trong hàm xử lý sự kiện cũng là element luôn :D.</p>

<p>Có thể làm thế này khi trong hàm <code>doSomething</code> muốn có <code>event object</code> và <code>this</code> là phần tử sinh ra
sự kiện.</p>

<p><code>javascript
linkEl.onclick = function(evt) {
  doSomething.call(this,evt);
}
</code></p>

<p>Trong trường hợp <code>doSomething</code> nhận thêm vài tham số thì nên viết như này:</p>

<p>```javascript
function doSomething(evt, param1, param2) {
//code implementation
}</p>

<p>linkEl.onclick = function(evt) {
  var param1, param2;
  doSomething.call(this, evt, param1, param2);
  // Giống với: doSomething.apply(this, [evt, param1, param2]);
}
```</p>

<p>Tiếp đến là mô hình thứ 3 và 4 trong xử lý sự kiện. W3C model và Microsoft (IE) model. Sau đó kết
hợp hai mô hình 3 và 4 này được giải pháp khá hoàn chỉnh và có thể sử dụng ngon lành đối với mọi
trình duyệt lớn :).</p>

<p><strong>3. W3C Event Registration Model</strong></p>

<p>Theo mô hình chuẩn của bạn W3C thì đây là cách đăng kí sự kiện cho một element, có thể đăng kí
cùng lúc nhiều hàm xử lý cho 1 element:</p>

<p><code>javascript
element.addEventListener(eventType, listener, useCapture);
</code></p>

<p><code>eventType</code> ở đây có thể là: click, mouseover, mouseout.v.v&hellip;</p>

<p><code>listener</code> chính là hàm xử lý sự kiện được thực thi khi có sự kiện <code>eventType</code> xảy ra.</p>

<p><code>useCapture</code> bạn nên để là <code>false</code> để thống nhất với trình duyệt IE, cái này liên quan tới event
phase mà tớ sẽ nói sau vào một bài viết khác.</p>

<p>Giờ có thể sử dụng như sau:</p>

<p><code>html
&lt;a href="#" id="mylink"&gt;link&lt;/a&gt;
</code></p>

<p>```javascript
//javascript, chỉ chạy trên các trình duyệt Firefox, Opera, Chrome
// ko chạy được trên IE
var linkEl = document.getElementById(&lsquo;myLink&rsquo;);
linkEl.addEventListener(&lsquo;click&rsquo;, function() {</p>

<pre><code>alert(arguments[0]); //event object
alert(this); //linkEl
</code></pre>

<p>}, false);
```</p>

<p>Rất may là <code>event object</code> lại được truyền và <code>this</code> trỏ luôn đến element nên có thể gọi
<code>doSomething</code> luôn:</p>

<p>```javascript
linkEl.addEventListener(&lsquo;click&rsquo;, function(evt) {</p>

<pre><code>doSomething.call(this, evt);
</code></pre>

<p>}, false);
```</p>

<p>Với cách này bạn có thể add bao nhiêu hàm xử lý sự kiện tùy ý, khi có 1 sự kiện xảy ra thì các hàm
xử lý sự kiện đã đăng kí sẽ được thực thi và theo W3C đưa ra thì các hàm này thực thi có thể không
theo thứ tự đăng kí và hiện tại bạn không thể gọi phương thức nào của element để kiểm tra xem sự
kiện nào đó có bao nhiêu hàm xử lý sự kiện đã được đăng kí.</p>

<p>Nhưng muốn bỏ một hàm xử lý đăng kí sự kiện thì làm thế nào? Có luôn:</p>

<p>```javascript</p>

<pre><code>element.removeEventListener(eventType, listener, useCapture);
</code></pre>

<p>```</p>

<p>Cái này rất hiếm khi dùng. Khi muốn <code>remove</code> được một <code>listener</code> nào thì <code>listener</code> đó phải có tên.
Cách <code>add</code> của tớ ở trên kia dùng <code>anonymouse function</code> thì không thể <code>remove</code> được. Muốn <code>remove</code>
được thì phải làm theo cách này:</p>

<p><code>javascript
var myListener = function() {
  alert(arguments[0]);
  alert(this);
 //cho chạy một lần đầu rồi remove listener đi luôn
  this.removeEventListener('click', myListener, false);
}
linkEl.addEventListener('click', myListener, false);
</code></p>

<p>Đấy là theo W3C, còn Microsoft lại làm theo cách khác.</p>

<p><strong>4. Microsoft Event Registration Model</strong></p>

<p>Bạn IE thì lại chơi kiểu khác, bạn ý không dùng <code>addEventListener</code> mà lại dùng:</p>

<p>```javascript</p>

<pre><code>element.attachEvent(onEventType, handler);
</code></pre>

<p>```</p>

<p>Ví dụ:</p>

<p><code>javascript
var linkEl = document.getElementById('myLink');
//Chỉ chạy trên IE
linkEl.attachEvent('onclick', function() {
  alert(arguments[0]); //event object
  alert(this); //linkEl
})
</code></p>

<p>Muốn remove một handler (listener) thì dùng <code>detachEvent</code> cũng làm tương tự giống mô hình W3C ở trên:</p>

<p><code>javascript
var myListener = function(evt) {
  alert(evt);
  alert(this);
  this.detachEvent('onclick', myListener);
}
</code></p>

<p>Chú ý vì IE không có 2 event phase là <code>capture</code> và <code>bubble</code> mà chỉ có <code>bubble</code> phase nên khi sử dụng
với mô hình của W3C thì luôn dùng <code>false</code> với <code>useCapture</code> cho an toàn, nếu hiểu kỹ sự khác biệt của
2 phase này và có mục đích thì mới nên dùng <code>true</code>.</p>

<p><strong>5. Cuối cùng là cách kết hợp mô hình W3C với M$ (IE) thì ta có thể thiết kế và sử api đơn giản như sau:</strong></p>

<p><code>javascript
addEventListener(element, eventType, listener, useCapture);
removeEventListener(element, eventType, listener, useCapture);
</code></p>

<p>Phải luôn giữ <code>event object</code> được truyền vào tham số của listener và từ khóa this trong listener
phải trỏ đến element. Code như sau:</p>

<p>```javascript
/<em>*
 * Cross browser add event listener method. For &lsquo;evt&rsquo; pass a string value with the leading &ldquo;on&rdquo; omitted
 * e.g. addEventListener(window,&lsquo;load&rsquo;,myFunctionNameWithoutParenthesis,false);
 * @param    obj object to attach event
 * @param    evt event name: click, mouseover, focus, blur&hellip;
 * @param    func    function name
 * @param    useCapture    true or false; if false => use bubbling
 * @static
 * @see        <a href="http://phrogz.net/JS/AttachEvent_js.txt">http://phrogz.net/JS/AttachEvent_js.txt</a>
 </em>/
 function addEventListener(obj, evt, fnc, useCapture) {</p>

<pre><code>if (obj === null || evt === null || fnc ===  null || useCapture === null) {
   alert('all params are required for addEventListener');
    return;
}
if (!useCapture) useCapture = false;
if (obj.addEventListener){
    obj.addEventListener(evt, fnc, useCapture);
} else if (obj.attachEvent) {
    obj.attachEvent('on'+evt, function(evt) {
        fnc.call(obj, evt);
    });
} else{
    myAttachEvent(obj, evt, fnc);
    obj['on'+evt] = function() { myFireEvent(obj,evt) };
}
//The following are for browsers like NS4 or IE5Mac which don't support either
//attachEvent or addEventListener
var myAttachEvent = function(obj, evt, fnc) {
    if (!obj.myEvents) obj.myEvents={};
    if (!obj.myEvents[evt]) obj.myEvents[evt]=[];
    var evts = obj.myEvents[evt];
    evts[evts.length] = fnc;
}
var myFireEvent = function(obj, evt) {
    if (!obj || !obj.myEvents || !obj.myEvents[evt]) return;
    var evts = obj.myEvents[evt];
    for (var i=0,len=evts.length;i&lt;len;i++) evts[i]();
}
</code></pre>

<p>}
/<em>*
 * removes event listener.
 * @param    obj element
 * @param    evt event name, &lsquo;click&rsquo;, &lsquo;blur&rsquo;. &lsquo;focus&rsquo;&hellip;
 * @func    function name to be removed if found
 * @useCapture true or false; false &ndash;> bubbling event phase
 * @static
 * //TODO make sure method cross-browsered
 </em>/
 function removeEventListener(obj, evt, func, useCapture) {</p>

<pre><code>if (obj.removeEventListener) {
    obj.removeEventListener(evt, func, useCapture);
} else if (obj.detachEvent) {//IE
    obj.detachEvent('on'+evt, func);
}
</code></pre>

<p>}
```</p>

<p>Khi đó cách sử dụng đơn giản như sau:</p>

<p>```javascript
  var linkEl = document.getElementById(&lsquo;myLink&rsquo;);
  addEventListener(&lsquo;click&rsquo;, function(evt) {</p>

<pre><code>doSomething.call(this, evt);
</code></pre>

<p>  }, false);
```</p>

<p>Hy vọng tớ sẽ sớm viết thêm về event phase sau, chúc bạn code vui :D.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Multiple event handlers for an element in JavaScript]]></title>
    <link href="http://blog.hoatle.info/2010/01/09/multiple-event-handlers-for-an-element-in-javascript/"/>
    <updated>2010-01-09T01:55:00+00:00</updated>
    <id>http://blog.hoatle.info/2010/01/09/multiple-event-handlers-for-an-element-in-javascript</id>
    <content type="html"><![CDATA[<p>This afternoon I caught a question posted in phpvietnam group:</p>

<p><strong>&ldquo;I have an input element with the property onclick="doSomeFunction();&rdquo;. Now I want to add another
function, ie onclick=&ldquo;doSomeFunction(); doSomeFunction2();&rdquo;, can I do this with JavaScript? Thanks
in advance!&ldquo; (translated)</strong></p>

<p><em>Source (in Vietnamese)</em>:
<a href="http://groups.google.com/group/phpvietnam/browse_thread/thread/c7a8688875a320c3">http://groups.google.com/group/phpvietnam/browse_thread/thread/c7a8688875a320c3</a></p>

<!-- more -->


<p>After answering his question, I just want to share my experience when working with JavaScript event
handler. I will show you 4 event registration models for the time beings of its use; the way to use
context and this keyword in function handler. My approach is that the event object will be passed
as 1st parameter to the function handler and this has to refer to the element triggering that event.</p>

<p><strong>1. Inline Event Registration Model</strong></p>

<p>From the first days of JavaScript, there is only one way of registering event handler and nowadays
this approach is still being used. Here we call the primitive approach:</p>

<p><code>html
&lt;a href="#" onclick="doSomething();"&gt;link&lt;/a&gt;
</code></p>

<p>People are so familiar with this event registration model, especially from the days of writing the
first lines of JavaScript code. There is nothing wrong with this kind of model, even it&rsquo;s
convenient, fast, easy to understand and people are still using this way :P. However, when
JavaScript evolves, the event registration approach changes because some problems arise: this
approach does not separate structure (html) and behaviour (JavaScript); this makes code more
complex, not very flexible to edit html. Just imagine when creating dom on the fly and constructing
new html fragment code to insert to html document? This approach does not seem fit well in this case.</p>

<p>Now working with event object and this keyword. We have the event handler function:</p>

<p><code>javascript
function doSomething(evt) {
  alert(arguments[0]); // arguments[0] the same as evt
  alert(this);
}
</code></p>

<p>In this case, when the link element is clicked, the <code>doSomething</code> handler function will be called
and <code>evt</code> will get <code>undefined (null)</code> value and <code>this</code> will refer to <code>window</code> object. This is not my
intention, I want the event has to be event object and this has to refer to the link element. So I
have to modify the code a little bit:</p>

<p><code>html
&lt;a href="#" onclick="doSomething(event);"&gt;link&lt;/a&gt;
</code></p>

<p>With above code, the event object is passed to <code>doSomething</code> handler function. In my assumption,
when link element is clicked, the <code>onclick</code> event is triggered from the browser native code:</p>

<p><code>javascript
//[Native Code]
onclick(event) {
  //event handler is called
  doSomething(event);
}
</code></p>

<p>Remember that we pass <code>event</code> as parameter to <code>doSomething</code> function but not any other name. If we
pass <code>evt</code> for example, the exception occurs:</p>

<p><code>javascript
[Native Code]
onclick(event) {
  //call event handler and pass evt as parameter
  doSomething(evt); //exception occured because evt is undefined (null).
}
</code></p>

<p>Because this is the browser native code, it does not allow to use <code>undefined (null)</code> value there.
However, we can pass any <code>undefined</code> or <code>null</code> parameter to any our JavaScript functions as normal,
there is no exception in this case. Note that the above code is tested with chrome and it just
works (?). No exception at all but not the case for IE, Firefox, Opera, Safari. Well, in this case
I don&rsquo;t know if google chrome is good or bad?</p>

<p>By using the event parameter passed to <code>doSomething</code> function, now we can get the event object to
get many useful properties there. For example, event type, cursor location, charCode, etc.,</p>

<p>Now we have to make sure <code>this</code> in <code>doSomething</code> function has to refer to link element, not
<code>window</code> object with the following code:</p>

<p><code>html
&lt;a href="#" onclick="doSomething.call(this, event)"&gt;link&lt;/a&gt;
</code></p>

<p>From the browser native code will trigger the <code>onclick</code> event as follows:</p>

<p><code>javascript
onclick(event) {
  //this is the triggred element
  doSomething.call(this, event);
}
</code></p>

<p>The above inline event registration code now works as my intention. I just explain in details in
this part only.</p>

<p><strong>2. Traditional Event Registration Model</strong></p>

<p>This is the model many developers use to separate structure and behaviour in the html document.
Html contains html only, and in JavaScript traditional event registration model will be used:</p>

<p><code>html
&lt;a href="#" id="mylink"&gt;link&lt;/a&gt;
</code></p>

<p>Make sure after the dom is loaded, this code will execute:</p>

<p><code>javascript
var linkEl = document.getElementById('myLink');
linkEl.onclick = function() {
  doSomething();
}
</code></p>

<p>This way of event registration is compatible with all major browsers. In this model, event object
is passed as the only parameter to the handler function and <code>this</code> in the handler function block
refer to linkEl.</p>

<p>Code this way to make sure <code>doSomething</code> function still has access to event object and <code>this</code> refers
to element triggering the event.</p>

<p><code>javascript
linkEl.onclick = function(evt) {
  doSomething.call(this,evt);
}
</code></p>

<p>In case the <code>doSomething</code> function has more than 1 arguments:</p>

<p>```javascript
function doSomething(evt, param1, param2) {
//code implementation
}</p>

<p>linkEl.onclick = function(evt) {
  var param1, param2;
  doSomething.call(this, evt, param1, param2);
  // same as: doSomething.apply(this, [evt, param1, param2]);
}
```</p>

<p>And then we come up with 3rd and 4th event registration model: W3C model and Microsof (IE) model.
By combining these 2 models, we got the solution for event registration compatible with all major
browsers:</p>

<p><strong>3. W3C Event Registration Model</strong></p>

<p>This is the specification of W3C to register event listener (handler). By using it, we can register
as many listeners as possible.</p>

<p><code>javascript
element.addEventListener(eventType, listener, useCapture);
</code></p>

<p><code>eventType</code>: click, mouseover, mouseout, etc.,</p>

<p><code>listener</code>: event handler function, it will be called when the element triggered eventType event.</p>

<p><code>useCapture</code>: you should always pass false to make it compatible with IE. This relates to event
phases which I will make another blog post about.</p>

<p>We can apply as:</p>

<p><code>html
&lt;a href="#" id="mylink"&gt;link&lt;/a&gt;
</code></p>

<p>```javascript
//javascript, run only on Firefox, Opera, Chrome, Safari
// can not run on IE
var linkEl = document.getElementById(&lsquo;myLink&rsquo;);
linkEl.addEventListener(&lsquo;click&rsquo;, function() {</p>

<pre><code>alert(arguments[0]); //event object
alert(this); //linkEl
</code></pre>

<p>}, false);
event object is passed as parameter and this refers to linkEl in event handler:</p>

<p>linkEl.addEventListener(&lsquo;click&rsquo;, function(evt) {</p>

<pre><code>doSomething.call(this, evt);
</code></pre>

<p>}, false);
```</p>

<p>By using this approach, you can add as many listeners as possible. When an eventType triggered, all
registered listeners will be executed. Note that W3C DOM specification does not require that the
first listener registered will be executed first, these listeners can be executed by random. And
till now, there is no way to check how many listeners registered in an element.</p>

<p><em>How about removing an event listener?</em></p>

<p><code>javascript
element.removeEventListener(eventType, listener, useCapture);
</code></p>

<p>I rarely use <code>removeEventListener</code>. You can not remove an anonymous function. From the above code,
I use anonymous function as listener, as the result, I can not find the way to remove it. Assigning
it a name and the problem solved:</p>

<p><code>javascript
var myListener = function() {
  alert(arguments[0]);
  alert(this);
 //first run and then remove listener, no event triggered from now anymore
  this.removeEventListener('click', myListener, false);
}
linkEl.addEventListener('click', myListener, false);
</code></p>

<p>This is the W3C way and M$ follows an other way.</p>

<p><strong>4. Microsoft Event Registration Model</strong></p>

<p>IE does not use <code>addEventListener</code> but <code>attachEvent</code>:</p>

<p>```javascript</p>

<pre><code>element.attachEvent(onEventType, handler);
</code></pre>

<p>```</p>

<p>For example:</p>

<p><code>javascript
var linkEl = document.getElementById('myLink');
//run on IE only
linkEl.attachEvent('onclick', function() {
  alert(arguments[0]); //event object
  alert(this); //linkEl
})
</code></p>

<p>Wanna remove a handler (listener)? Use <code>detachEvent</code>:</p>

<p><code>javascript
var myListener = function(evt) {
  alert(evt);
  alert(this);
  this.detachEvent('onclick', myListener);
}
</code></p>

<p>Note that IE does not have 2 event phases (capture and bubble) but bubble phase only. So when using
W3C, you should always use <code>false</code> for <code>useCapture</code> for safety purpose :d. If you fully understand
these 2 event phases, you can pass true for <code>useCapture</code> but intentionally.</p>

<p><strong>5. At last, combine these 2 models for simple and compatible api:</strong></p>

<p><code>javascript
//api design
addEventListener(element, eventType, listener, useCapture);
removeEventListener(element, eventType, listener, useCapture);
</code></p>

<p>My intention is that event object has to be passed as 1st parameter to listener and this has to
refer to the element in the block code. Here we come the solution:</p>

<p>```javascript
/<em>*
 * Cross browser add event listener method. For &lsquo;evt&rsquo; pass a string value with the leading &ldquo;on&rdquo; omitted
 * e.g. addEventListener(window,&lsquo;load&rsquo;,myFunctionNameWithoutParenthesis,false);
 * @param    obj object to attach event
 * @param    evt event name: click, mouseover, focus, blur&hellip;
 * @param    func    function name
 * @param    useCapture    true or false; if false => use bubbling
 * @static
 * @see        <a href="http://phrogz.net/JS/AttachEvent_js.txt">http://phrogz.net/JS/AttachEvent_js.txt</a>
 </em>/
function addEventListener(obj, evt, fnc, useCapture) {</p>

<pre><code>if (obj === null || evt === null || fnc ===  null || useCapture === null) {
   alert('all params are required for addEventListener');
    return;
}
if (!useCapture) useCapture = false;
if (obj.addEventListener){
    obj.addEventListener(evt, fnc, useCapture);
} else if (obj.attachEvent) {
    obj.attachEvent('on'+evt, function(evt) {
        fnc.call(obj, evt);
    });
} else{
    myAttachEvent(obj, evt, fnc);
    obj['on'+evt] = function() { myFireEvent(obj,evt) };
}

//The following are for browsers like NS4 or IE5Mac which don't support either
//attachEvent or addEventListener
var myAttachEvent = function(obj, evt, fnc) {
    if (!obj.myEvents) obj.myEvents={};
    if (!obj.myEvents[evt]) obj.myEvents[evt]=[];
    var evts = obj.myEvents[evt];
    evts[evts.length] = fnc;
}

var myFireEvent = function(obj, evt) {
    if (!obj || !obj.myEvents || !obj.myEvents[evt]) return;
    var evts = obj.myEvents[evt];
    for (var i=0,len=evts.length;i&lt;len;i++) evts[i]();
}
</code></pre>

<p>}</p>

<p>/<em>*
 * removes event listener.
 * @param    obj element
 * @param    evt event name, &lsquo;click&rsquo;, &lsquo;blur&rsquo;. &lsquo;focus&rsquo;&hellip;
 * @func    function name to be removed if found
 * @static
 * //TODO make sure method cross-browsered
 </em>/
function removeEventListener(obj, evt, func, useCapture) {</p>

<pre><code>if (obj.removeEventListener) {
    obj.removeEventListener(evt, func, useCapture);
} else if (obj.detachEvent) {//IE
    obj.detachEvent('on'+evt, func);
}
</code></pre>

<p>}
```</p>

<p>Use this api as simple as:</p>

<p>```javascript
  var linkEl = document.getElementById(&lsquo;myLink&rsquo;);
  addEventListener(linkEl, &lsquo;click&rsquo;, function(evt) {</p>

<pre><code>doSomething.call(this, evt);
</code></pre>

<p>  }, false);
```</p>

<p>Hope that you find this post interesting, I will blog about 2 event phases soon. Happy coding :D</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Thiết kế một trang kiểm tra thuật ngữ đơn giản]]></title>
    <link href="http://blog.hoatle.info/2008/12/19/thiet-ke-mot-trang-kiem-tra-thuat-ngu-don-gian/"/>
    <updated>2008-12-19T00:14:00+00:00</updated>
    <id>http://blog.hoatle.info/2008/12/19/thiet-ke-mot-trang-kiem-tra-thuat-ngu-don-gian</id>
    <content type="html"><![CDATA[<p>Đây là 1 trang thuần Client: HTML + JavaScript + XML.
XML là file dữ liệu. Xương sống của chương trình đơn giản này chính là JavaScript.</p>

<!-- more -->


<p>Học dịch trong trường thế nên cuối kì tớ hay có kiểu kiểm tra thuật ngữ => Điều tất yếu là phải
học các term. Đến hẹn lại lên, cứ cuối mỗi kỳ thường có mấy đứa học thi + tớ viết cái này để test
thử + học nhanh hơn.</p>

<p>Một năm trước code thuần JavaScript, nghĩa là viết theo kiểu procedure, không OOP. Tớ vừa chỉnh
lại 1 vài thứ, sau 1 năm xem lại vẫn hiểu code của chính mình :)).</p>

<p>Đây là demo: <a href="http://wayback.archive.org/web/20091130065808/http://d9k50.net/test/term7">http://wayback.archive.org/web/20091130065808/http://d9k50.net/test/term7</a> Có thể tớ
sẽ nói chi tiết hơn nếu bạn nào muốn hỏi gì :).</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[JavaScript – Xương sống của ứng dụng web hiện đại]]></title>
    <link href="http://blog.hoatle.info/2008/11/10/javascript-xuong-song-cua-ung-dung-web-hien-dai/"/>
    <updated>2008-11-10T20:13:00+00:00</updated>
    <id>http://blog.hoatle.info/2008/11/10/javascript-xuong-song-cua-ung-dung-web-hien-dai</id>
    <content type="html"><![CDATA[<p>Javascript ư? Đây mà được gọi là ngôn ngữ lập trình à? Ngôn ngữ lập trình thực sự phải là C,
Java.v.v&hellip; cơ. Quan điểm lạc hậu này không thể tồn tại khi bạn thực sự làm việc và nghiên cứu
JavaScript một cách nghiêm túc. Trong những ngày đầu JavaScript hầu như chỉ được dùng làm một số
hiệu ứng và phần lớn là hiện cửa sổ pop-up quảng cáo. Càng dần về sau, JavaScript được một số nhà
phát triển phát hiện và đưa ra những khái niệm, những cách thức để sử dụng JavaScript theo hướng
hiện đại – hướng đối tượng với JavaScript. Vậy JavaScript là gì? Nó không phải là Java :). Nó có
hướng đối tượng như các ngôn ngữ lập trình lớn – hoàn toàn hướng đối tượng nhưng cách tiếp cận khác
hơn, động hơn. JavaScript có vai trò rất lớn trong các trình duyệt web hiện đại cũng như công nghệ
web 2.0. Và rồi JavaScript sẽ đi đến đâu? Trong bài viết này tôi xin giải đáp ngắn gọn một số câu
hỏi trên.</p>

<!-- more -->


<p>Thứ nhất, JavaScript không phải là Java :) và chẳng có mối liên hệ nào với Java cả, có chăng là cả
2 cái tên đều có &ldquo;Java&rdquo;. JavaScript chỉ được dùng trong các trình duyệt, đầu tiên có tên là
LiveScript do Netscape phát triển để tạo tính động và tương tác hơn cho các nhà phát triển xử lý
tài liệu. Sau đó Jscript được Microsoft phát triển cho trình duyệt IE của mình. Cái tên JavaScript
cũng có liên quan một chút đến Java ;). Hồi đó Java rất được ưa chuộng và JavaScript được đặt tên
như vậy cũng là để thu hút được nhiều sự chú ý hơn. Nhưng tôi xin nhấn mạnh JavaScript và Java là
hoàn toàn khác nhau cả về phạm vi sử dụng cũng như cách thức sử dụng. Trong một số bài viết tiếp
theo tôi sẽ nói cụ thể hơn về phạm vi cũng như cách thức sử dụng ngôn ngữ của thế giới web 2.0 này.</p>

<p>JavaScript hướng đối tượng hoàn toàn? Đúng thế, ngay từ đầu JavaScript là ngôn ngữ động và hoàn toàn
hướng đối tượng. Chỉ có cách triển khai theo hướng đối tượng là khác các ngôn ngữ hướng đối tượng
thông thường khác như C++ hay Java. Chỉ do cách viết JavaScript của một số những người mới học ngôn
ngữ này viết theo kiểu &ldquo;procedure&rdquo; thực hiện một số công việc đơn giản – sau đó tạo ra làn sóng sử
dụng JavaScript tràn lan vì JavaScript rất dễ sử dụng nhưng sử dụng tốt hay không lại là vấn đề
khác :|</p>

<p>JavaScript là xương sống của trình duyệt web hiện đại và công nghệ web 2.0: Đối với các ứng dụng web
hiện đại, mỗi một trang web gồm 3 thành phần không thể tách rời: Structure-Presentation-Behavior.
(X)HTML cho phần structure (semantic structure). Ở phần này bạn chỉ tạo ra cấu trúc HTML có nghĩa,
không dùng đến bất kì thẻ nào để định dạng hay trình bày tài liệu trên trình duyệt. Công việc này
là dành cho CSS – Cascading Style Sheet – định dạng và trình bày trang web dựa trên các lựa chọn
(CSS selector) để định dạng các thẻ (tag), class và id có trong cấu trúc tài liệu. Và phần quan
trọng cuối cùng chính là JavaScript – tạo tương tác cho trang web. Ở đây tôi nói tương tác không còn
là các hiệu ứng hoạt hình thông thường hay những cửa sổ Popup quảng cáo, mà chính là những tương tác
để tạo những trải nghiệm mới cho người dùng theo các sự kiện tương tác (click chuột, di chuột,
ấn nút&hellip;), đấy mới là tương tác thực sự.</p>

<p>JavaScript sẽ đi đến đâu? Trong vài năm trở lại đây, những thư viện và framework JavaScript phát
triển không ngừng. Không thể không kể đến extjs (phát triển từ thư viện YUI của Yahoo!), Dojo,
prototypejs, jQuery và còn nhiều framework khác nữa. Hiện tại và trong tương lai JavaScript sẽ đóng
vai trò xương sống trong các trình duyệt web và JavaScript đã thực sự khẳng định được chỗ đứng của
mình. Trước đây Java Applet đã từng làm mưa làm gió, giờ là thời đại của JavaScript.</p>

<p>JavaScript rất mạnh mà vẻ đẹp của JavaScript không thể nói hết được nếu bạn không thực sự tận hưởng
vẻ đẹp của JavaScript. Hãy lập trình tốt, bỏ những thói quen xấu và tận hưởng vẻ đẹp đó :).</p>

<p>Một số cuốn sách nên đọc: Pro JavaScript Techniques (John Resig – project leader của jQuery), Pro
JavaScript Design Patterns (Ross Harmes và Dustin Diaz), và JavaScript: The Good Parts (Douglas
Crockford – Kiến trúc sư trưởng bên Yahoo!).</p>

<p>Một số liên kết cần ghé qua:</p>

<p><a href="http://javascript.crockford.com/">http://javascript.crockford.com/</a></p>

<p><a href="https://developer.mozilla.org/en/JavaScript">https://developer.mozilla.org/en/JavaScript</a></p>

<p>Và đừng quên google nhá ;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[November 08, 2007 - Phần 1_Ajax là gì? (2)]]></title>
    <link href="http://blog.hoatle.info/2007/11/08/november-08-2007-phan-1-ajax-la-gi-2/"/>
    <updated>2007-11-08T03:14:00+00:00</updated>
    <id>http://blog.hoatle.info/2007/11/08/november-08-2007-phan-1-ajax-la-gi-2</id>
    <content type="html"><![CDATA[<p>[Xin ghi rõ nguồn <a href="http://360.yahoo.com/wild_tiger8607">Hoat Le’s blog</a> khi muốn đăng lại các bài
viết trong <strong>Ajax Series</strong>]</p>

<p>Cần thời gian cho nhiều việc khác, chuyện gì đã qua sẽ qua không nói lại nữa. Chúng ta tiếp tục với
Ajax Series, lâu rồi chưa sờ đến nó, lại tiếp tục cùng mọi người “ngâm cứu” nào. Lần này sẽ là giọng
như viết sách, không thích kiểu “informal” nữa vì hơi “bát nháo” :(. Đêm nay chỉ type thôi.</p>

<!-- more -->


<p>Ở Entry trước chúng ta đã tìm hiểu một số thông tin cơ bản về Ajax, sự ra đời của Ajax. Tiếp tục
trong phần này sẽ giúp các bạn tìm hiểu sâu hơn nữa về Ajax – thuật ngữ rất “hot” từ năm 2005.</p>

<p><strong>1.3 Sự phát triển của Web</strong></p>

<p>Năm 1990, khi Tim Berners-Lee lần đầu tiên đưa bản dự thảo cho thế giới Web (World Wide Web) thì ý
tưởng của ông khá giản đơn: tạo ra một mạng thông tin được kết nối với nhau sử dụng siêu văn bản
(hypertext) và bộ định danh tài nguyên thống nhất (Uniform Resource Identifiers &ndash; URIs). Khả năng
liên kết các loại tài liệu khác nhau từ khắp nơi trên thế giới đã tạo ra tiềm năng rất lớn cho những
người đang tìm kiếm học bổng vì mọi người có thể dễ dàng truy xuất các tài liệu tham khảo gần như
ngay tức khắc. Hơn nữa, phiên bản đầu tiên của ngôn ngữ đánh dấu siêu văn bản (HyperText Markup
Language &ndash; HTML) có rất ít tính năng, chỉ để định dạng và liên kết các tài liệu, đó là một nền không
phải để xây dựng phần mềm giàu tính tương tác mà chỉ là nơi chia sẻ các loại tài liệu minh hoạ và
văn bản đã thống trị thế giới in ấn. Web đã phát triển từ những trang web tĩnh như vậy.</p>

<p>Khi Web phát triển, các nhà kinh doanh sớm nhận ra khả năng tiềm ẩn đưa thông tin về các sản phẩm và
dịch vụ của mình tới đông đảo mọi người trên mạng. Thế hệ tiếp theo của Web đã có nhiều khả năng
định dạng và hiển thị thông tin hơn vì HTML cũng đã phát triển để đáp ứng nhu cầu phù hợp với những
kì vọng của những người sử dụng biết đến kiểu truyền thông mới này. Nhưng một công ty nhỏ &ndash; Netscape
– ngay sau đó đã nhanh chóng đẩy tốc độ phát triển của Web nhanh hơn rất nhiều.</p>

<p>Note: Bắt đầu từ năm 1994 Netscape bắt đầu cuộc chiến giữa các trình duyệt (browser wars) khi đưa ra
hàng loạt các thẻ HTML mở rộng như hiển thị màu chữ, hiện ảnh.. trong trình duyệt của mình mà trong
các trình duyệt khác sẽ báo lỗi hoặc ra kết quả hiện thị không như mong muốn, hoặc không hiện gì cả.
Nhưng mọi người thích những mở rộng này và đều muốn sử dụng trình duyệt của Netscape để duyệt web.
Đến năm 1996, trình duyệt của Netscape đã trở thành chương trình máy tính phổ biến nhất thế giới. Có
thể nói đây là thời kì hoàng kim nhất của Netscape cho đến khi Microsoft cũng phát triển, cuốn hút
người dùng bằng cách thêm những phần mở rộng không phải là chuẩn vào trình duyệt của mình mà trình
duyệt khác không hiển thị hoặc báo lỗi. Bắt đầu từ đây cuộc chiến giữa 2 ông trùm trình duyệt bắt
đầu, nảy sinh rất nhiều vấn đề không tương thích cho các nhà phát triển. Đến những năm 2000,
Internet Explorer đã khẳng định vị trí số 1 của mình, trở thành trình duyệt phổ biến nhất đi cùng
hệ điều hành Windows. Đến năm 2004, trình duyệt mã nguồn mở Mozilla Firefox chính thức ra phiên bản
1.0. Đến năm 2005 sản phẩm mã nguồn mở từ bộ Mozilla Suite của Netscape đã được bình chọn là sản
phẩm số 1. Mozilla Firefox hoàn toàn miễn phí và ngày càng được ưa chuộng bởi các nhà phát triển,
người dùng. Và hiện nay Mozilla Firefox đã trở thành trình duyệt số 1 được sử dụng nhiều nhất trên
thế giới.</p>

<p><strong>1.4 JavaScript</strong></p>

<p>Netscape Navigator là trình duyệt web chủ đạo thành công trước nhất và cũng là trình duyệt đầu tiên
đẩy nhanh các công nghệ web. Tuy nhiên, Netscape thường bị chỉ trích bởi các tổ chức tiêu chuẩn vì
đã tiến hành áp dụng những công nghệ mới và các mở rộng cho các công nghệ hiện hành trước khi các
chuẩn được ban hành (rất giống Microsoft cũng bị chỉ trích vì đã không theo các chuẩn khi phát triển
Internet Explorer). Một trong những công nghệ được Netscape phát triển là JavaScript.</p>

<p>Đầu tiên được đặt tên là LiveScript, JavaScript đã được Brendan Eich của Netscape tạo ra và có trong
trình duyệt phiên bản 2.0 (1995). Đây là lần đầu tiên các nhà phát triển có thể tác động tới trang
web để tương tác với người dùng. Thay vì phải bắt server phải thực hiện nhiệm vụ đơn giản như kiểm
tra tính hợp lệ của dữ liệu, chúng ta có thể làm cho trình duyệt có thể kiểm tra tính hợp lệ của dữ
liệu ngay mà không cần gửi tới server. Khả năng này rất quan trọng tại thời điểm đó khi hầu hết
người dùng Internet sử dụng modem 28.8 Kbps, nếu gửi yêu cầu tới <em>server</em> thì sẽ trở thành game đợi
chờ (Có lúc người ta nói vui với nhau: WWW – World Wide Wait). Giảm thiểu số lần người dùng phải đợi
<em>response</em> từ <em>server</em> chính là bước lớn đầu tiên tiến tới cách tiếp cận Ajax.</p>

<p><strong>1.5 Frames (Khung)</strong></p>

<p>Phiên bản đầu tiên của HTML có mục đích tạo ra các tài liệu đứng độc lập một mình và đến tận HTML
4.0 <em>frame</em> mới được chính thức giới thiệu. Ý tưởng hiển thị một trang web từ một số tài liệu được
gộp lại là một ý tưởng cấp tiến đầy tranh luận đã được Netscape chọn để đưa vào tính năng cho trình
duyệt trước khi hoàn thành HTML 4.0. Netscape Navigator 2.0 là trình duyệt đầu tiên hỗ trợ các
<em>frame</em> và cả JavaScript. Đây là một bước tiến quan trọng trong sự phát triển của Ajax.</p>

<p>Vào cuối những năm 1990 khi cuộc chiến giữa các trình duyệt (browser wars) giữa Microsoft và
Netscape nổ ra thì cả JavaScript và frame đều được chính thức hoá. Khi ngày càng có nhiều tính năng
được hỗ trợ bởi 2 trình duyệt, các nhà phát triển sáng tạo bắt đầu thử nghiệm sử dụng cả 2 tính năng
này của trình duyệt. Do một frame đại diện cho một <em>request</em> hoàn toàn độc lập tới <em>server</em> nên khả
năng kiểm soát một <em>frame</em> và nội dung của nó bằng JavaScript đã mở cánh cửa cho một số khả năng lí
thú.</p>

<p>Trong bài viết tới sẽ đề cập tới một số kỹ thuật cơ bản sử dụng <em>frame</em> để gửi yêu cầu tới <em>server</em>
mà không cần <em>load</em> lại trang.</p>
]]></content>
  </entry>
  
</feed>
